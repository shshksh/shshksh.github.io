---
title: "안드로이드 액티비티"
excerpt: "안드로이드 액티비티의 생성과 수명 주기"
classes: wide
categories: 
  - Android
tag:
  - android
  - activity
read_time: false
last_modified_at: 2020-03-12T17:37:00+09:00
toc: true
---

## 안드로이드 액티비티

액티비티 1개는 애플리케이션이 사용자에게 제시하는 **화면 1개**를 나타낸다.

일반적으로 1차 인터페이스 화면이라고 할 수 있는 메인 액티비티는 애플리케이션의 메인 UI를 담당하므로 반드시 포함된다. 이 1차 인터페이스는 일반적으로 여러 2차 액티비티의 지원을 받는다. 다른 화면으로 전환하려면 새 액티비티를 시작하거나 기존 액티비티에서 복귀해야 한다.



## 액티비티 생성

새 액티비티를 만들 때는 Activity 클래스 또는 서브클래스 중 1개로부터 **상속**받는 서브 클래스를 생성한다. 대체로  **AppCompatActivity**를 상속하여 사용한다.

```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        // layout 리소스의 activity_main을 호출하여 액티비티에 지정
    }
}
```

기본 Activity 클래스는 빈 화면을 나타내며, **프래그먼트**와 **레이아웃**, **뷰**를 사용하여 **UI**를 만들어야 한다.

**뷰는** 데이터를 표시하고 사용자 상호 작용를 제공하는 **UI 위젯/컨트롤**이다. 안드로이드는 몇 가지 레이아웃 클래스를 제공한다. 이들을 묶어 **뷰 그룹**(View Group)이라고 하며, UI를 **배치**하는 데 유용한 여러 뷰를 제공한다.

애플리케이션에서 액티비티를 사용하려면 **manifests** 파일에 등록해야 한다. 등록을 위해 새 **activity 태그**를 매니페스트의 **application** 노드 안에 추가한다.

```xml
<activity android:name=".MainActivity">
    <intent-filter>
        <action android:name="android.intent.action.MAIN" />

        <category android:name="android.intent.category.LAUNCHER" />
    </intent-filter>
</activity>
```

activity 태그는 Activity가 사용하는 레이블, 아이콘, 요구 권한, 테마 등과 같은 **메타 데이터 속성**들도 포함한다. activity 태그가 없는 액티비티는 사용될 수 없다. 그런 액티비티를 시작하려고 하면 런타임 예외가 발생한다.

activity 태그 안에 **intent-filter** 노드를 추가할 수도 있다. 이 노드는 액티비티를 시작하는 데 사용될 수 있는 인텐트를 지정할 때 필요하다. 인텐트 필터는 Activity가 지원하는 하나 이상의 **액션**과 **카테고리**를 **정의**한다.



## AppCompatActivity

안드로이드 지원 라이브러리(ASL) 에서 사용할 수 있는 Activity의 **서브클래스**이다. 이 클래스는 최신 안드로이드 버전의 Activity 클래스에 새로 추가된 기능들을 구 버전의 안드로이드에서 사용할 수 있게 **하위 호환성**을 **제공**한다. 따라서 Activity 대신  AppCompatActivity를 우선 사용하는 것이 바람직하다.



## 액티비티의 수명 주기

각 애플리케이션의 프로세스와 그 안의 각 액티비티를 **ART**가 관리하므로 애플리케이션은 자신의 프로세스 수명을 **제어하지 않는다**.

ART는 액티비티의 프로세스에 대한 종료와 관리를 처리한다. 그러나 액티비티의 상태는 자신이 속한 애플리케이션의 우선순위를 결정하게 된다. 그리고 애플리케이션의 우선순위를 기준으로 ART는 해당 애플리케이션과 그 내부에서 실행되는 액티비티들을 종료시킨다.

- **액티비티 상태와 LRU 리스트**

  액티비티의 상태는 액티비티 스택(또는 백 스택) 내의 위치에 따라 결정된다. 새 액티비티가 시작하면 활성상태가 되고 스택에서 맨 위로 옮겨진다. 사용자가 뒤로 가기 버튼을 눌러 뒤로 이동하거나 포어그라운드 액티비티가 다른 이유로 닫히면 스택에서 아래쪽에 있던 순서상 그다음 액티비티가 위로 옮겨지고 활성 상태가 된다. 애플리케이션의 우선순위는 자신의 액티비티중 우선순위가 높은 것의 영향을 받는다. 

  애플리케이션의 어떤 액티비티도 보이는 상태가 아닐 때는 애플리케이션 자체가 LRU(least recently used) 리스트에 오른다. LRU 리스트는 리소스를 확보하기 위해 중단할 애플리케이션들의 순서를 결정하는 데 사용된다.

- **액티비티의 상태**

  - **활성**
     : 스택에서 맨 위에 있는 액티비티는 가시적이고 포커스를 가진 포어그라운드 액티비티로, 사용자의 입력을 받는다. 안드로이드는 어떻게든 이 액티비티가 살아서 동작하게 해준다. 경우에 따라 활성 액티비티가 필요한 리소스를 확보하기 위해 스택의 아래쪽 액티비티를 가진 애플리케이션을 종료시킨다.
- **일시 정지**
     : 보이기만 할 뿐 포커스를 갖지 않는 상태이다. 멀티윈도우 환경의 애플리케이션에 흔하다. 포커스를 갖지 않기 때문에 사용자의 입력을 받지 않는다.
  - **정지**
   : 액티비티는 보이지 않을 때 멈춘다. 이때 메모리에 그대로 남아 모든 상태 정보를 유지하지만 시스템에서 메모리를 확보할 때 중단될 유력한 후보가 된다. 액티비티가 정지 상태로 전환될 때는 데이터와 현재 UI 상태 정보를 저장하고 모든 처리를 멈추어야 한다. 액티비티가 종료되거나 닫히면 비활성 상태가 된다.
  - **비활성**
     : 액티비티가 실행된 적이 있지만 종료되었다면 비활성 상태가 된다. 비활성 액티비티는 액티비티 스택에서 제거되며, 다시 화면에 나타나서 사용하려면 재시작돼야 한다.



## 액티비티의 수명

안드로이드는 액티비티가 상태 변화에 반응할 수 있도록 일련의 **이벤트 핸들러**를 제공하고 있다. 이벤트 핸들러는 액티비티가 전체 수명, 가시 수명, 활성 수명 으로 전환될 때 **자동**으로 **호출**되어 실행된다. 

액티비티는 전체 수명 동안, 즉 생성과 소멸 사이에서 활성 수명과 가시 수명을 한 번 이상 반복하게 된다. 각 수명 간의 전환이 발생하면 앞서 언급한 메서드 핸들러가 실행된다.

- **전체 수명**

  **onCreate**의 **첫 호출** 부터 **소멸**까지. 소멸시 액티비티의 프로세스가 onDestroy 핸들러 호출 없이 중단될 수도 있다.

  - **onCreate**
     : 액티비티의 초기화 담당. 구체적으로 UI를 전개하고, 프래그먼트의 참조를 가져오고, 해당 참조를 클래스 변수에 지정하고, 데이터를 컨트롤에 바인딩하고 서비스를 시작한다. 만일 액티비티가 런타임에 의해 예기치 않게 중단되면 onSavedIntstanceState의 마지막 호출 때 저장된 상태가 담긴 Bundle 객체가 onCreate 메서드에 전달된다. onCreate나 onSavedInstanceState 메서드에서는 Bundle 객체를 사용하여 UI를 이전 상태로 복구해야 한다.

  - **onDestroy**
     : onCreate로 생성된 리소스를 클린업하고 네트워크 또는 데이터베이스 링크와 같은 외부 연결이 모두 닫혔는지 확인하기 위해 onDestory를 오버라이드 한다. 효율적인 코드를 작성하기 위한 안드로이드 가이드라인에 따라 잠시 사용할 객체를 반복해 생성하지 않는 것이 좋다. 객체를 생성하고 소멸시키는 일이 잦으면 사용자 경험에 직접적인 악영향을 끼키는 가비지 컬렉터가 수행된다. 액티비티가 정해진 객체들을 생성한다면 onCreate 메서드에 하는 것이 좋다.

- **가시 수명**

  **onStart** 에서 **onStop** 호출까지이다. 이 두 호출 사이의 액티비티는 사용자에게 보이게 된다. 단, 이는 포커스의 유무와 무관하며, 액티비티가 부분적으로 가려질 수도 있다. 액티비티는 전체 수명 동안 포어그라운드와 백그라운드를 넘나들며 몇 번의 가시 수명을 반복한다.

  - **onStop**
     : 애니메이션이나 스레드, 센서 리스너, GPS 조회, 타이머, 서비스 등 UI를 업데이트 할 때만 사용되는 프로세스들을 일시 정지 또는 정지하는 데 사용돼야 한다. UI가 화면에 보이지 않을 때 메모리나 CPU 또는 네트워크 등의 리소스를 사용하는 프로세스의 정지는 onStop에서 하지 않는다. 그리고 정지된 프로세스의 재시작은 onStart 메서드를 사용한다.

  - **onRestart**
    onStart의 최초 호출을 제외한 모든 경우에 앞서 호출된다. 액티빝가 전체 수명 안에서 재시작될 때만 수행되는 특별한 처리를 구현할 때 onRestart 메서드를 사용한다.

  onStart/onStop 메서드는 오직 UI 업데이트에만 사용되는 브로드캐스트 리시버를 등록하거나 등록 해제할 때도 사용된다.

- **활성 수명**

  **onResume**의 호출에서 **onPause** 호출까지이다.

  활성 액티비티는 포어그라운드에 있으며, 사용자 입력 이벤트를 받는다. 액티비티는 소멸하기까지 활성 수명을 여러 번 거친다. 포어그라운드를 드나들 때 애플리케이션의 반응성을 좋게 유지하도록 onPause와 onResume 메서드의 코드를 빠르고 간단하게 작성하자. 활성 수명 동안에는 프로세스가 중단되기 전에 onPause가 호출된다고 생각하면 된다.

  - **onPause**
    안드로이드 3.0 허니콤부터 그 이후로는 onStop 메서드의 실행이 끝나야만 액티비티가 예고 없이 종료될 수 있다. 따라서 액티비티 상태 데이터의 저장에 필요한 모든 시간 소요 작업을 onStop에서 하면 된다. 이에 따라 onPause 메서드에서는 간단한 작업을 수행하면 되며, 또한 액티비티가 활성 상태가 아닐 동안 메모리나 CPU를 많이 사용하는 작업을 중지할 수 있다.

  - **onResume**
    마찬가지로 간단한 작업만 수행해야 한다. 그러나 UI 상태 데이터를 다시 로드할 필요는 없다. UI 상태 데이터는 onCreate와 onRestoreInstanceState 메서드에서 처리되어야 하기 때문이다. onResume은 onPause 안에서 수행된 작업을 역으로 처리하는 데 사용한다. 예를 들어, 해지된 리소스의 할당, 제거되거나 등록되지 않은 컴포넌트의 초기화 또는 등록, 중지된 작업의 재개 등이다.

