## Thrashing

CPU 스케줄러와 메모리 관리자 사이의 상호작용에 의해 발생.



thrashing 의 발생 과정

- 시스템에 충분히 많은 프로세스가 동작 중
- 동작중인 프로세스가 요구하는 메모리가 가용한 피지컬 메모리보다 많아서 페이지 폴트가 발생
- 페이지 폴트를 처리하는 동안 프로세스는 블록당하게 되므로 CPU 사용성이 낮아짐
- CPU 스케줄러는 시스템이 한가한 것으로 판단하고 더 많은 프로세스들을 동작시킴
- 메모리가 더욱 부족해짐으로써 악순환이 반복



thrashing 은 global replacement style 과도 연관이 있다. 모든 프로세스가 하나의 페이지 풀을 사용하기 때문에.

그렇다면 local allocation(per-process or per-job) 을 통해 thrashing 을 해결할 수 있는가?

그렇지는 않다. 특정 프로세스가 과도하게 메모리를 사용하여 다른 프로세스가 영향을 받는 현상은 막을 수 있다.

하지만 메모리가 부족하여 페이지 폴트가 발생한다는것은 블록 디바이스의 큐가 점점 채워진다는 것이고, 이는 메모리가 충분한 프로세스도 페이지 폴트가 발생하면 대기시간이 길어질 수 밖에 없다.

본질적인 문제는 현재 동작중인 프로세스가 요구하는 메모리가 너무 많다는 점이다. (또는 degree of multi-programing 이 너무 크다)

단순히 사용자의 PC 라면 사용하지 않는 프로세스를 죽이는 것으로 쉽게 해결할 수 있다.



스마트폰처럼 스왑 디바이스가 없는 경우 많은 프로세스로 인해 메모리가 부족하면 어떻게 처리하는가?

안드로이드의 로우 메모리 킬러와 같이 동작 중인 프로세스를 강제로 종료시켜 완전히 메모리에서 제거할 수 밖에 없음 



**working set**

어느 시점에 특정 프로세스가 액세스하는 페이지들의 집합

**prepaging(prefetching)**

실제 페이지 요청이 있기 전에 향후 액세스될 것으로 예상되는 페이지를 미리 메모리에 로드하는 것



## Trends in memory management

**issues**

- 메모리 사이즈의 확장
  - 페이지 교체 알고리즘의 중요도 하락
  - 교체 정책에 대한 하드웨어적 지원 감소
  - 페이지 사이즈의 증가
- 가상 메모리 공간의 확장
- 다른 서비스와의 상호작용



**large page table handling**

- 페이지 테이블을 유지하기 위해 필요한 공간이 너무 큼
- 페이지 테이블이 피지컬 메모리의 연속적인 공간에 존재해야 함

